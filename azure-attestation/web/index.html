<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attestation Report</title>
    <script type="module">
        import { jwtVerify } from 'https://cdn.skypack.dev/jose';

        async function validateJWT() {
            try {
                // Store referenceState in a higher scope
                const referenceState = await fetchReferenceState();
                if (!referenceState) {
                    throw new Error("Failed to fetch reference state");
                }

                const nonce = generateNonce();
                const jwtToken = await fetchToken(nonce);
                if (!jwtToken) {
                    throw new Error("Failed to fetch token");
                }

                const header = decodeJwtHeader(jwtToken);
                if (!header.jku || !header.kid) {
                    throw new Error("Missing jku or kid in token header");
                }

                if (header.alg !== 'RS256') {
                    throw new Error(`Unsupported algorithm: ${header.alg}`);
                }

                const key = await fetchPublicKey(header.jku, header.kid);
                const { payload, protectedHeader } = await jwtVerify(jwtToken, key, {
                    algorithms: ['RS256']
                });
                
                const now = Math.floor(Date.now() / 1000);
                const isExpired = payload.exp < now;

                // Pass both the claims and referenceState to displayClaims
                displayClaims(payload, {
                    isValidSignature: true,
                    isExpired: isExpired
                }, referenceState);

            } catch (error) {
                const errorMessage = error.code === 'ERR_JWS_VERIFICATION_FAILED' 
                    ? "Signature verification failed" 
                    : error.message;
                
                displayClaims(null, {
                    isValidSignature: false,
                    errorMessage: `Verification Error: ${errorMessage}`
                }, null);
                console.error("JWT Validation Error:", error);
            }
        }

        window.onload = validateJWT;

        // Clean up interval when page is unloaded
        window.addEventListener('unload', () => {
            if (window.timeUpdateInterval) {
                clearInterval(window.timeUpdateInterval);
            }
        });

        //===============================================
        // Implimentation functions
        //===============================================

        async function fetchToken(nonce) {
            try {
                const response = await fetch(`/.well-known/attest/token?nonce=${nonce}`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                return data.token;
            } catch (error) {
                console.error("Error fetching token:", error);
            }
        }

        async function fetchReferenceState() {
            try {
                const response = await fetch("/.well-known/attest/reference");
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching reference state:", error);
            }
        }

        async function fetchPublicKey(jku, kid) {
            try {
                const response = await fetch(jku);
                const { keys } = await response.json();
                const keyData = keys.find(k => k.kid === kid);
                if (!keyData) throw new Error("Matching public key not found");

                return await crypto.subtle.importKey(
                    "jwk",
                    keyData,
                    {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: { name: "SHA-256" }
                    },
                    false,
                    ["verify"]
                );
            } catch (error) {
                console.error("Error fetching public key:", error);
                throw new Error("Failed to import public key");
            }
        }

        function performReferenceChecks(claims, reference) {
            const results = [];

            // Check 1: reference.measurement + reference.host-data equals x-ms-sevsnpvm-launchmeasurement
            const expectedLaunchMeasurement = ((reference.measurement || "") + (reference["host-data"] || "")).toLowerCase();
            const actualLaunchMeasurement = (claims["x-ms-isolation-tee"]?.["x-ms-sevsnpvm-launchmeasurement"] || "").toLowerCase();
            results.push({
                description: "Launch Measurement Check",
                expected: expectedLaunchMeasurement,
                actual: actualLaunchMeasurement,
                valid: expectedLaunchMeasurement === actualLaunchMeasurement
            });

            // Check 2: reference.vmid equals x-ms-azurevm-vmid
            const expectedVmid = (reference.vmid || "").toLowerCase();
            const actualVmid = (claims["x-ms-azurevm-vmid"] || "").toLowerCase();
            results.push({
                description: "VM ID Check",
                expected: expectedVmid,
                actual: actualVmid,
                valid: expectedVmid === actualVmid
            });

            // Check 3: reference.manifest equals base64decoded x-ms-runtime.client-payload.manifest
            const encodedManifest = claims["x-ms-runtime"] && claims["x-ms-runtime"]["client-payload"]
                                    ? claims["x-ms-runtime"]["client-payload"].manifest
                                    : "";
            const decodedManifest = base64Decode(encodedManifest).toLowerCase();
            const expectedManifest = (reference.manifest || "").toLowerCase();
            results.push({
                description: "Manifest Check",
                expected: expectedManifest,
                actual: decodedManifest,
                valid: expectedManifest === decodedManifest
            });

            // Check 4: reference.certificate equals base64decoded x-ms-runtime.client-payload.cert
            const encodedCert = claims["x-ms-runtime"] && claims["x-ms-runtime"]["client-payload"]
                                ? claims["x-ms-runtime"]["client-payload"].cert
                                : "";
            const decodedCert = base64Decode(encodedCert).toLowerCase();
            const expectedCert = (reference.certificate || "").toLowerCase();
            results.push({
                description: "Certificate Check",
                expected: expectedCert,
                actual: decodedCert,
                valid: expectedCert === decodedCert
            });

            return results;
        }

        function displayReferenceChecks(checks, outputDiv, referenceState) {
            const section = document.createElement('div');
            section.className = 'claim-section reference-checks';
            section.innerHTML = `
                <h3>Reference Data Checks</h3>
                <p class="description">Verification of runtime values against expected reference values.</p>
                ${referenceState?.source ? `
                <div class="reference-source">
                    <div class="reference-source-header">
                        <svg class="source-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        <span>Reference values from verifiable build:</span>
                    </div>
                    <a href="${referenceState.source}" target="_blank" rel="noopener noreferrer" class="reference-source-link">
                        ${referenceState.source}
                        <svg class="external-link-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6M15 3h6v6M10 14L21 3"/>
                        </svg>
                    </a>
                </div>
                ` : ''}
            `;
            
            checks.forEach(check => {
                const resultBadge = document.createElement('span');
                resultBadge.className = `security-status ${check.valid ? 'valid' : 'invalid'}`;
                resultBadge.innerText = check.valid ? 'PASS' : 'FAIL';
                
                const checkDiv = document.createElement('div');
                checkDiv.className = 'check-item';

                // Add browser instructions specifically in the Certificate Check section
                if (check.description === "Certificate Check") {
                    const browser = detectBrowser();
                    checkDiv.innerHTML = `
                        <div>${resultBadge.outerHTML} <strong>${check.description}</strong></div>
                        <div class="values-container">
                            <div class="value-row">
                                <span class="value-label">Expected:</span>
                                <span class="value-content">${check.expected || '(empty)'}</span>
                            </div>
                            <div class="value-row">
                                <span class="value-label">Actual:</span>
                                <span class="value-content">${check.actual || '(empty)'}</span>
                            </div>
                        </div>
                        <div class="certificate-verification-guide">
                            <div class="guide-header">
                                <svg class="verify-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/>
                                </svg>
                                <span>Verify in ${browser}</span>
                            </div>
                            <div class="guide-steps">
                                ${getBrowserSpecificInstructions(browser)}
                            </div>
                        </div>
                    `;
                } else {
                    checkDiv.innerHTML = `
                        <div>${resultBadge.outerHTML} <strong>${check.description}</strong></div>
                        <div class="values-container">
                            <div class="value-row">
                                <span class="value-label">Expected:</span>
                                <span class="value-content">${check.expected || '(empty)'}</span>
                            </div>
                            <div class="value-row">
                                <span class="value-label">Actual:</span>
                                <span class="value-content">${check.actual || '(empty)'}</span>
                            </div>
                        </div>
                    `;
                }
                section.appendChild(checkDiv);
            });
            outputDiv.appendChild(section);
        }

        function generateNonce(length = 32) {
            const array = new Uint8Array(length);
            window.crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function base64Decode(input) {
            try {
                return atob(input);
            } catch(e) {
                console.error("Error decoding base64:", e);
                return "";
            }
        }

        function decodeJwtHeader(token) {
            try {
                const [header] = token.split(".");
                return JSON.parse(atob(header));
            } catch (error) {
                console.error("Error decoding JWT header:", error);
                throw new Error("Invalid JWT header");
            }
        }

        function formatTimestamp(unixTimestamp, claimKey) {
            function getFormattedTime() {
                const date = new Date(unixTimestamp * 1000);
                const now = Date.UTC(
                    new Date().getUTCFullYear(),
                    new Date().getUTCMonth(),
                    new Date().getUTCDate(),
                    new Date().getUTCHours(),
                    new Date().getUTCMinutes(),
                    new Date().getUTCSeconds()
                );
                const diffSeconds = Math.round((unixTimestamp * 1000 - now) / 1000);
                
                // Date formatting options
                const options = { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric', 
                    hour: 'numeric', 
                    minute: '2-digit', 
                    hour12: true,
                    timeZone: 'UTC',
                    timeZoneName: 'short'
                };
                const formattedDate = date.toLocaleString('en-US', options);

                // Calculate time difference
                const timeUnits = [
                    { unit: 'day', seconds: 86400 },
                    { unit: 'hour', seconds: 3600 },
                    { unit: 'minute', seconds: 60 }
                ];
                
                let relativeTime = '';
                if (diffSeconds >= 0) {
                    relativeTime = 'in ';
                } else {
                    relativeTime = '';
                }
                
                let seconds = Math.abs(diffSeconds);
                for (const { unit, seconds: unitSeconds } of timeUnits) {
                    const count = Math.floor(seconds / unitSeconds);
                    if (count > 0) {
                        relativeTime += `${count} ${unit}${count !== 1 ? 's' : ''} `;
                        seconds %= unitSeconds;
                    }
                }
                
                if (seconds > 0 || relativeTime === '' || relativeTime === 'in ') {
                    relativeTime += `${seconds} second${seconds !== 1 ? 's' : ''}`;
                }

                if (diffSeconds < 0) {
                    relativeTime += ' ago';
                }
                
                return {
                    html: `
                        <div class="timestamp">
                            <span class="${claimKey === 'exp' && diffSeconds < 0 ? 'expired' : ''}">
                                ${formattedDate}
                            </span>
                            <span class="relative-time" data-timestamp="${unixTimestamp}">(${relativeTime})</span>
                        </div>
                    `,
                    relativeTime: relativeTime
                };
            }

            // Initial render
            const initialResult = getFormattedTime();
            const timestampElement = document.createElement('div');
            timestampElement.innerHTML = initialResult.html;
            
            const relativeTimeSpan = timestampElement.querySelector('.relative-time');
            if (relativeTimeSpan) {
                // Store timestamp and key as data attributes
                relativeTimeSpan.dataset.unixTimestamp = unixTimestamp;
                relativeTimeSpan.dataset.claimKey = claimKey;
            }

            return timestampElement.innerHTML;
        }

        function createSecurityBadge(value) {
            const elem = document.createElement('span');
            elem.className = `security-status ${value ? 'valid' : 'invalid'}`;
            elem.innerText = value ? 'YES' : 'NO';
            return elem;
        }

        function formatValue(value, key) {
            if (typeof value === 'boolean') {
                return createSecurityBadge(value).outerHTML;
            }
            if (typeof value === 'string' && value.match(/^[0-9a-f]{32,}$/i)) {
                return `<span class="hex-value">${value}</span>`;
            }
            if (key.toLowerCase().includes('measurement') || key.toLowerCase().includes('digest')) {
                return `<span class="hex-value">${value}</span>`;
            }
            return value;
        }

        function formatNestedObject(data, level = 0, labelMapping = {}) {
            const container = document.createElement('div');
            container.className = 'nested-object';
            
            for (const [key, value] of Object.entries(data)) {
                const row = document.createElement('div');
                row.className = 'claim-group';
                row.style.marginLeft = `${level * 20}px`;
                
                const mapping = labelMapping[key] || {};
                const label = mapping.label || key;
                const description = mapping.description || '';
                
                if (key === 'keys' && Array.isArray(value)) {
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'nested-header';
                    headerDiv.innerHTML = `<strong>${label}</strong>`;
                    if (description) {
                        headerDiv.innerHTML += `<div class="description">${description}</div>`;
                    }
                    row.appendChild(headerDiv);

                    value.forEach((keyObj, index) => {
                        const keyDiv = document.createElement('div');
                        keyDiv.className = 'key-info';
                        keyDiv.innerHTML = `<div class="key-info-header">Key ${index + 1}</div>`;
                        
                        for (const [keyProp, keyValue] of Object.entries(keyObj)) {
                            const propMapping = mapping.nested?.[keyProp] || {};
                            const propLabel = propMapping.label || keyProp;
                            const formatFn = propMapping.format || (v => formatValue(v, keyProp));
                            const formattedValue = formatFn(keyValue);
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'key-info-item';
                            
                            if (keyProp === 'n' || keyValue.length > 50) {
                                itemDiv.innerHTML = `
                                    <span class="key-info-label">${propLabel}:</span>
                                    <div class="hex-value" onclick="this.classList.toggle('expanded')">${keyValue}</div>
                                `;
                            } else if (Array.isArray(keyValue)) {
                                itemDiv.innerHTML = `
                                    <span class="key-info-label">${propLabel}:</span>
                                    <span>${keyValue.join(', ')}</span>
                                `;
                            } else {
                                itemDiv.innerHTML = `
                                    <span class="key-info-label">${propLabel}:</span>
                                    <span>${formattedValue}</span>
                                `;
                            }
                            keyDiv.appendChild(itemDiv);
                        }
                        row.appendChild(keyDiv);
                    });
                } else if (typeof value === 'object' && value !== null) {
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'nested-header';
                    headerDiv.innerHTML = `<strong>${label}</strong>`;
                    if (description) {
                        headerDiv.innerHTML += `<div class="description">${description}</div>`;
                    }
                    row.appendChild(headerDiv);
                    
                    const nestedMapping = mapping.nested || {};
                    row.appendChild(formatNestedObject(value, level + 1, nestedMapping));
                } else {
                    let formattedValue = formatValue(value, key);
                    if (typeof value === 'boolean') {
                        formattedValue = createSecurityBadge(value).outerHTML;
                    }
                    
                    row.innerHTML = `
                        <div>
                            <strong>${label}:</strong>
                            <div class="claim-value">${formattedValue}</div>
                            ${description ? `<div class="description">${description}</div>` : ''}
                        </div>
                    `;
                }
                
                container.appendChild(row);
            }
            return container;
        }

        function detectBrowser() {
            const userAgent = navigator.userAgent;
            
            if (userAgent.includes("Firefox")) {
                return "Firefox";
            } else if (userAgent.includes("Safari") && !userAgent.includes("Chrome")) {
                return "Safari";
            } else if (userAgent.includes("Chrome") || userAgent.includes("Edg")) {
                return "Chrome";
            }
            return "Unknown";
        }

        function startTimerUpdates() {
            // Clear any existing interval
            if (window.timeUpdateInterval) {
                clearInterval(window.timeUpdateInterval);
            }

            // Set up new interval
            window.timeUpdateInterval = setInterval(() => {
                document.querySelectorAll('.relative-time').forEach(span => {
                    const timestamp = parseInt(span.dataset.unixTimestamp);
                    const claimKey = span.dataset.claimKey;
                    if (timestamp) {
                        const result = formatTimestamp(timestamp, claimKey);
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = result;
                        const newSpan = tempDiv.querySelector('.relative-time');
                        if (newSpan) {
                            span.textContent = newSpan.textContent;
                        }
                    }
                });
            }, 1000);
        }

        // Define human readable labels for claims
        const humanLabels = {
            exp: { label: "Expiration Time", description: "The time when the token expires." },
            iat: { label: "Issued At", description: "The time when the token was issued." },
            nbf: { label: "Not Valid Before", description: "The token is not valid before this time." },
            secureboot: { label: "Secure Boot", description: "Indicates whether secure boot is enabled on the VM." },
            "x-ms-azurevm-vmid": { label:"VM ID", description:"Unique identifier for the virtual machine." },
            "x-ms-azurevm-osbuild": { label:"OS Build", description:"OS build information." },
            "x-ms-azurevm-osdistro": { label:"OS Distribution", description:"Name of the OS distribution." },
            "x-ms-azurevm-ostype": { label:"OS Type", description:"Operating system type." },
            "x-ms-azurevm-osversion-major": { label:"OS Version (Major)", description:"Major version number of the OS." },
            "x-ms-azurevm-osversion-minor": { label:"OS Version (Minor)", description:"Minor version number of the OS." },
            "x-ms-azurevm-is-windows": { label:"Windows OS", description:"Indicates if the virtual machine is running Windows operating system." },
            "x-ms-azurevm-dbvalidated": { label:"DB Validation", description:"Indicates if the DB component has been validated." },
            "x-ms-azurevm-dbxvalidated": { label:"DBX Validation", description:"Indicates if the DBX component has been validated." },
            "x-ms-azurevm-default-securebootkeysvalidated": { label:"Secure Boot Keys Validated", description:"Indicates if secure boot keys have been validated." },
            "x-ms-azurevm-hypervisordebug-enabled": { label:"Hypervisor Debugging", description:"Indicates if hypervisor debugging is enabled." },
            "x-ms-azurevm-bootdebug-enabled": { label:"Boot Debugging", description:"Indicates if boot debugging is enabled on the VM." },
            "x-ms-azurevm-debuggersdisabled": { label:"Debuggers Disabled", description:"Indicates if debuggers are disabled." },
            "x-ms-azurevm-kerneldebug-enabled": { label:"Kernel Debugging", description:"Indicates if kernel debugging is enabled." },
            "x-ms-azurevm-flightsigning-enabled": { label:"Flight Signing", description:"Indicates if flight signing is enabled." },
            "x-ms-azurevm-testsigning-enabled": { label:"Test Signing", description:"Indicates if test signing is enabled." },
            "x-ms-azurevm-signingdisabled": { label:"Signing Disabled", description:"Indicates if secure signing is disabled on the VM." },
            "x-ms-azurevm-elam-enabled": { label:"ELAM Protection", description:"Indicates if ELAM (Early Launch Anti-Malware) is enabled." },
            "x-ms-azurevm-hvci-policy": { label:"HVCI Policy", description:"Hypervisor Code Integrity (HVCI) policy value." },
            "x-ms-azurevm-attestation-type": { label:"Attestation Type", description:"The type of attestation used for the VM." },
            "x-ms-azurevm-attestation-protocol-ver": { label:"Attestation Protocol Version", description:"Version of the attestation protocol used." },
            "x-ms-azurevm-attested-pcrs": { label:"Attested PCRs", description:"List of PCRs (Platform Configuration Registers) attested." },
            "x-ms-policy-hash": { label:"Policy Hash", description:"Hash representing the attestation policy configuration." },
            "x-ms-runtime": { label:"Runtime Information", description:"Attestation runtime­-related information." }
        };

        // Define sections configuration
        const sections = {
            'timestamps': ['exp', 'iat', 'nbf'],
            'vmConfig': key => key.startsWith('x-ms-azurevm'),
            'isolationTee': key => key.startsWith('x-ms-isolation-tee'),
            'runtimeInfo': key => key.startsWith('x-ms-runtime'),
            'securityPolicy': ['x-ms-policy-hash', 'secureboot']
        };

        // Define section headings
        const sectionHeadings = {
            timestamps: { 
                label: "Token Validity", 
                description: "Timestamps related to token validity." 
            },
            vmConfig: { 
                label: "Virtual Machine Configuration", 
                description: "Configuration information specific to the Azure VM." 
            },
            isolationTee: { 
                label: "Isolation TEE Data", 
                description: "Detailed data from the Trusted Execution Environment." 
            },
            runtimeInfo: { 
                label: "Attestation Runtime Information", 
                description: "Runtime properties associated with the attestation." 
            },
            securityPolicy: { 
                label: "Security Policy", 
                description: "Security settings and policy hash." 
            }
        };

        // Define labels for Isolation TEE Data
        const isolationTeeLabels = {
            "x-ms-attestation-type": { 
                label: "Attestation Type", 
                description: "The type of isolation used for the virtual machine",
                format: value => createSecurityBadge(value).outerHTML
            },
            "x-ms-compliance-status": { 
                label: "Compliance Status", 
                description: "Compliance status of the virtual machine",
                format: value => createSecurityBadge(value).outerHTML
            },
            "x-ms-runtime": {
                label: "Runtime Configuration",
                description: "Runtime configuration and keys for the TEE environment",
                nested: {
                    "keys": { 
                        label: "Security Keys", 
                        description: "Cryptographic keys used in the TEE",
                        nested: {
                            "e": { label: "Exponent", format: value => formatValue(value, 'e') },
                            "key_ops": { label: "Operations", format: value => formatValue(value, 'key_ops') },
                            "kid": { label: "Key ID", format: value => formatValue(value, 'kid') },
                            "kty": { label: "Key Type", format: value => formatValue(value, 'kty') },
                            "n": { label: "Modulus", format: value => formatValue(value, 'n') }
                        }
                    },
                    "user-data": { 
                        label: "User Data", 
                        description: "User-specific data in the TEE",
                        format: value => formatValue(value, 'user-data')
                    },
                    "vm-configuration": { 
                        label: "VM Configuration", 
                        description: "Virtual machine configuration settings",
                        nested: {
                            "console-enabled": { 
                                label: "Console Enabled", 
                                description: "Whether console access is enabled",
                                format: value => createSecurityBadge(value).outerHTML
                            },
                            "secure-boot": { 
                                label: "Secure Boot", 
                                description: "Whether secure boot is enabled",
                                format: value => createSecurityBadge(value).outerHTML
                            },
                            "tpm-enabled": { 
                                label: "TPM Enabled", 
                                description: "Whether TPM is enabled",
                                format: value => createSecurityBadge(value).outerHTML
                            },
                            "vmUniqueId": { 
                                label: "VM Unique ID", 
                                description: "Unique identifier for the virtual machine",
                                format: value => formatValue(value, 'vmUniqueId')
                            }
                        }
                    }
                }
            },
            "x-ms-sevsnpvm-authorkeydigest": { 
                label: "Author Key Digest", 
                description: "Cryptographic digest of the attestation author key",
                format: value => formatValue(value, 'authorkeydigest')
            },
            "x-ms-sevsnpvm-bootloader-svn": { 
                label: "Bootloader Version", 
                description: "Security Version Number of the bootloader",
                format: value => formatValue(value, 'bootloader-svn')
            },
            "x-ms-sevsnpvm-familyId": { 
                label: "Family ID", 
                description: "Identifier for the VM family",
                format: value => formatValue(value, 'familyId')
            },
            "x-ms-sevsnpvm-guestsvn": { 
                label: "Guest Version", 
                description: "Security Version Number of the guest OS",
                format: value => formatValue(value, 'guestsvn')
            },
            "x-ms-sevsnpvm-hostdata": { 
                label: "Host Data", 
                description: "Data provided by the host system",
                format: value => formatValue(value, 'hostdata')
            },
            "x-ms-sevsnpvm-idkeydigest": { 
                label: "ID Key Digest", 
                description: "Cryptographic digest of the identity key",
                format: value => formatValue(value, 'idkeydigest')
            },
            "x-ms-sevsnpvm-imageId": { 
                label: "Image ID", 
                description: "Identifier for the VM image",
                format: value => formatValue(value, 'imageId')
            },
            "x-ms-sevsnpvm-is-debuggable": { 
                label: "Debuggable", 
                description: "Whether the system is in debug mode",
                format: value => createSecurityBadge(value).outerHTML
            },
            "x-ms-sevsnpvm-launchmeasurement": { 
                label: "Launch Measurement", 
                description: "Cryptographic measurement taken at launch time",
                format: value => formatValue(value, 'launchmeasurement')
            },
            "x-ms-sevsnpvm-microcode-svn": { 
                label: "Microcode Version", 
                description: "Security Version Number of the CPU microcode",
                format: value => formatValue(value, 'microcode-svn')
            },
            "x-ms-sevsnpvm-migration-allowed": { 
                label: "Migration Allowed", 
                description: "Whether VM migration is allowed",
                format: value => createSecurityBadge(value).outerHTML
            },
            "x-ms-sevsnpvm-reportdata": { 
                label: "Report Data", 
                description: "Raw attestation report data",
                format: value => formatValue(value, 'reportdata')
            },
            "x-ms-sevsnpvm-reportid": { 
                label: "Report ID", 
                description: "Unique identifier for this attestation report",
                format: value => formatValue(value, 'reportid')
            },
            "x-ms-sevsnpvm-smt-allowed": { 
                label: "SMT Allowed", 
                description: "Whether Simultaneous Multi-Threading is allowed",
                format: value => createSecurityBadge(value).outerHTML
            },
            "x-ms-sevsnpvm-snpfw-svn": { 
                label: "SNP Firmware Version", 
                description: "Security Version Number of the SNP firmware",
                format: value => formatValue(value, 'snpfw-svn')
            },
            "x-ms-sevsnpvm-tee-svn": { 
                label: "TEE Version", 
                description: "Security Version Number of the Trusted Execution Environment",
                format: value => formatValue(value, 'tee-svn')
            },
            "x-ms-sevsnpvm-vmpl": { 
                label: "VM Privilege Level", 
                description: "Current privilege level of the virtual machine",
                format: value => formatValue(value, 'vmpl')
            }
        };

        // Helper function to create claim group
        function createClaimGroup(key, value, sectionName) {
            const group = document.createElement('div');
            group.className = 'claim-group';
            const label = humanLabels[key]?.label || key;
            const desc = humanLabels[key]?.description || '';

            if (key === 'x-ms-azurevm-attested-pcrs' && Array.isArray(value)) {
                group.innerHTML = `
                    <div><strong>${label}:</strong></div>
                    <div class="pcr-list">
                        ${value.map(pcr => `<div class="pcr-item">PCR ${pcr}</div>`).join('')}
                    </div>
                    ${desc ? `<div class="description">${desc}</div>` : ''}
                `;
            } else if (typeof value === 'object' && value !== null) {
                group.innerHTML = `<div><strong>${label}:</strong></div>`;
                if (sectionName === 'isolationTee') {
                    group.appendChild(formatNestedObject(value, 0, isolationTeeLabels));
                } else {
                    group.appendChild(formatNestedObject(value));
                }
                if (desc) {
                    group.innerHTML += `<div class="description">${desc}</div>`;
                }
            } else {
                let formattedValue = formatValue(value, key);
                if (typeof value === 'boolean') {
                    formattedValue = createSecurityBadge(value).outerHTML;
                }
                
                group.innerHTML = `
                    <div>
                        <strong>${label}:</strong>
                        <div class="claim-value">${formattedValue}</div>
                        ${desc ? `<div class="description">${desc}</div>` : ''}
                    </div>
                `;
            }

            return group;
        }

        function displayBrowserInstructions() {
            const browser = detectBrowser();
            const instructionsDiv = document.getElementById('browserInstructions');
            
            instructionsDiv.innerHTML = `
                <div class="browser-instructions">
                    <h4>How to Verify the Certificate</h4>
                    <p>To manually verify that the certificate hash matches the one shown in the Reference Data Checks section, follow these steps for ${browser}:</p>
                    
                    <div class="browser-specific">
                        ${getBrowserSpecificInstructions(browser)}
                    </div>
                    
                    <p>Compare this certificate hash with the one shown in the "Certificate Check" section above. They should match exactly.</p>
                </div>
            `;
        }

        function getBrowserSpecificInstructions(browser) {
            switch(browser) {
                case "Chrome":
                    return `
                        <ol>
                            <li>Click the padlock icon in the address bar</li>
                            <li>Click "Connection is secure"</li>
                            <li>Click "Certificate is valid"</li>
                            <li>Go to the "Details" tab</li>
                            <li>Scroll down to find "Thumbprint" (SHA-1)</li>
                        </ol>`;
                case "Firefox":
                    return `
                        <ol>
                            <li>Click the padlock icon in the address bar</li>
                            <li>Click the ">" arrow next to "Connection secure"</li>
                            <li>Click "More Information"</li>
                            <li>In the Security tab, click "View Certificate"</li>
                            <li>Go to the "Details" tab</li>
                            <li>Find "Fingerprint (SHA-1)"</li>
                        </ol>`;
                case "Safari":
                    return `
                        <ol>
                            <li>Click the padlock icon in the address bar</li>
                            <li>Click "Show Certificate"</li>
                            <li>Click "Details"</li>
                            <li>Find "SHA-1 Certificate Fingerprint"</li>
                        </ol>`;
                default:
                    return `
                        <ol>
                            <li>Click the padlock icon in the address bar</li>
                            <li>Look for certificate or security information</li>
                            <li>Find the certificate details</li>
                            <li>Look for SHA-1 fingerprint or thumbprint</li>
                        </ol>`;
            }
        }

        function displayClaims(claims, validation, referenceState) {
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';

            if (!validation.isValidSignature || validation.errorMessage) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'claim-section invalid';
                errorDiv.innerHTML = `
                    <h3 style="margin:0">Attestation Result: 
                        <span class="security-status">${validation.errorMessage || "Invalid Token Signature"}</span>
                    </h3>
                    ${validation.errorMessage ? `<p class="description">${validation.errorMessage}</p>` : ''}
                `;
                outputDiv.appendChild(errorDiv);
                return;
            }

            // Create validity banner
            const validityBanner = createValidityBanner(claims, validation);
            outputDiv.appendChild(validityBanner);

            // Process sections in order
            Object.entries(sections).forEach(([sectionName, matcher]) => {
                if (sectionName === 'timestamps') {
                    const timestampSection = createTimestampSection(claims, sectionName, matcher);
                    if (timestampSection) {
                        outputDiv.appendChild(timestampSection);

                        // Add reference checks right after timestamps section
                        if (claims && referenceState?.reference) {
                            const referenceChecks = performReferenceChecks(claims, referenceState.reference);
                            displayReferenceChecks(referenceChecks, outputDiv, referenceState);
                        }
                    }
                } else {
                    const section = createSection(claims, sectionName, matcher);
                    if (section) {
                        outputDiv.appendChild(section);
                    }
                }
            });
            
            startTimerUpdates();
        }

        // Helper function to create validity banner
        function createValidityBanner(claims, validation) {
            const banner = document.createElement('div');
            banner.className = `claim-section ${validation.isValidSignature ? 'valid' : 'invalid'}`;
            banner.innerHTML = `
                <h3 style="margin:0">Attestation Result: 
                    <span class="security-status">${validation.isValidSignature ? 'VALID SIGNATURE' : 'INVALID SIGNATURE'}</span>
                    ${validation.isExpired ? '<span class="security-status expired">(EXPIRED)</span>' : ''}
                </h3>
                <div class="issuer-url">Issuing Authority: <a href="${claims.iss}" target="_blank">${claims.iss}</a></div>
                <p class="description">Signature verification ${validation.isValidSignature ? 'succeeded' : 'failed'}${validation.isExpired ? ' but token has expired' : ''}.</p>
            `;
            return banner;
        }

        // Helper function to create timestamp section
        function createTimestampSection(claims, sectionName, matcher) {
            const sectionClaims = Object.entries(claims).filter(([key]) =>
                Array.isArray(matcher) ? matcher.includes(key) : matcher(key)
            );

            if (sectionClaims.length === 0) return null;

            const section = document.createElement('div');
            section.className = 'claim-section';
            section.innerHTML = `<h3>${sectionHeadings[sectionName]?.label || sectionName}</h3>
            <p class="description">${sectionHeadings[sectionName]?.description || ''}</p>`;
            
            const timelineDiv = document.createElement('div');
            timelineDiv.className = 'timeline';
            
            // Find iat and nbf values
            const iatClaim = sectionClaims.find(([key]) => key === 'iat');
            const nbfClaim = sectionClaims.find(([key]) => key === 'nbf');
            const expClaim = sectionClaims.find(([key]) => key === 'exp');
            
            // Add Issued At
            if (iatClaim) {
                const [key, value] = iatClaim;
                const label = humanLabels[key]?.label || key;
                timelineDiv.innerHTML += `
                    <div class="timeline-item">
                        <div class="timeline-label">${label}</div>
                        <div class="timeline-value">${formatTimestamp(value, key)}</div>
                    </div>
                `;
            }
            
            // Add Not Valid Before only if different from Issued At
            if (nbfClaim && (!iatClaim || nbfClaim[1] !== iatClaim[1])) {
                const [key, value] = nbfClaim;
                const label = humanLabels[key]?.label || key;
                timelineDiv.innerHTML += `
                    <div class="timeline-item">
                        <div class="timeline-label">${label}</div>
                        <div class="timeline-value">${formatTimestamp(value, key)}</div>
                    </div>
                `;
            }
            
            // Add Expiration
            if (expClaim) {
                const [key, value] = expClaim;
                const label = humanLabels[key]?.label || key;
                timelineDiv.innerHTML += `
                    <div class="timeline-item">
                        <div class="timeline-label">${label}</div>
                        <div class="timeline-value">${formatTimestamp(value, key)}</div>
                    </div>
                `;
            }
            
            section.appendChild(timelineDiv);
            return section;
        }

        // Helper function to create other sections
        function createSection(claims, sectionName, matcher) {
            const sectionClaims = Object.entries(claims).filter(([key]) =>
                Array.isArray(matcher) ? matcher.includes(key) : matcher(key)
            );

            if (sectionClaims.length === 0) return null;

            const section = document.createElement('div');
            section.className = 'claim-section';
            section.innerHTML = `<h3>${sectionHeadings[sectionName]?.label || sectionName}</h3>
            <p class="description">${sectionHeadings[sectionName]?.description || ''}</p>`;

            // Sort claims for vmConfig section
            if (sectionName === 'vmConfig') {
                const sortedClaims = Object.keys(humanLabels)
                    .filter(key => matcher(key) && sectionClaims.some(([k]) => k === key))
                    .map(key => sectionClaims.find(([k]) => k === key));
                sectionClaims.length = 0;
                sectionClaims.push(...sortedClaims);
            }

            sectionClaims.forEach(([key, value]) => {
                const group = createClaimGroup(key, value, sectionName);
                section.appendChild(group);
            });

            return section;
        }
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.5;
            color: #333;
            background: #f5f7f9;
        }

        .container {
            max-width: 900px;
            margin: 30px auto;
            padding: 0 20px;
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        h3 {
            color: #2c3e50;
            margin: 0 0 15px 0;
        }

        .claim-section { 
            margin: 25px 0; 
            padding: 20px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .claim-group { 
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .claim-group:hover {
            background: #f1f3f5;
        }

        .nested-object {
            margin: 10px 0;
        }

        .timestamp { 
            color: #666;
            font-family: inherit;
        }

        .security-status { 
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.9em;
            display: inline-block;
            margin: 3px 0;
        }

        .valid { 
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .invalid { 
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .monospace { 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            background: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .description {
            font-size: 0.85em;
            color: #666;
            margin: 5px 0;
            font-style: italic;
        }

        /* Hex value styling */
        .hex-value {
            font-family: monospace;
            background: #f6f8fa;
            padding: 3px 6px;
            border-radius: 3px;
            border: 1px solid #e1e4e8;
            word-break: break-all;
        }

        /* Section header with icon */
        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        /* Value formatting */
        .claim-value {
            margin-top: 3px;
            word-break: break-word;
        }

        /* Boolean value styling */
        .bool-value {
            font-weight: 500;
        }

        .bool-true {
            color: #28a745;
        }

        .bool-false {
            color: #dc3545;
        }

        .pcr-list {
            margin: 10px 0;
            padding-left: 20px;
        }

        .pcr-item {
            font-family: monospace;
            padding: 3px 0;
            color: #2c3e50;
        }

        .nested-header {
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #eaecef;
        }

        .nested-object .claim-group {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }

        .nested-object .claim-group:hover {
            background: #f8f9fa;
        }

        .claim-value {
            margin: 5px 0;
            padding: 5px 0;
        }

        /* Key information styling */
        .key-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 5px 0;
        }

        .key-info-item {
            font-size: 0.9em;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .key-info .hex-value {
            font-size: 0.85em;
            max-height: 2.4em;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: max-height 0.3s ease-out;
        }

        .key-info .hex-value.expanded {
            max-height: none;
        }

        .key-info-label {
            font-weight: 500;
            color: #495057;
            margin-right: 5px;
        }

        .browser-instructions {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }

        .browser-instructions h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }

        .browser-instructions h5 {
            margin: 15px 0 10px 0;
            color: #2c3e50;
        }

        .browser-specific {
            margin: 15px 0;
        }

        .browser-specific ol {
            margin: 10px 0;
            padding-left: 25px;
        }

        .browser-specific li {
            margin: 5px 0;
            color: #495057;
        }

        .relative-time {
            font-size: 0.9em;
            color: #666;
            margin-left: 8px;
            display: inline-block;
        }

        .expired {
            color: #dc3545;
            font-weight: bold;
        }

        .timestamp {
            margin: 5px 0;
        }

        .issuer-url {
            margin: 10px 0;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .issuer-url a {
            color: #3498db;
            text-decoration: none;
            word-break: break-all;
        }

        .issuer-url a:hover {
            text-decoration: underline;
        }

        .test-description {
            background: #e8f4f8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .test-description p {
            margin: 10px 0;
            color: #2c3e50;
        }
        
        .test-description ul, .test-description ol {
            margin: 10px 0;
            padding-left: 25px;
        }
        
        .test-description li {
            margin: 5px 0;
        }
        
        .test-description a {
            color: #3498db;
            text-decoration: none;
        }
        
        .test-description a:hover {
            text-decoration: underline;
        }

        /* New styles for Reference Data Checks */
        .reference-checks {
            background: #f8f9fa;
            border: 1px solid #e1e4e8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .check-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .check-item:hover {
            background: #fafbfc;
        }

        .check-item > div {
            margin: 5px 0;
        }

        .check-item .value-row {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 10px;
            align-items: baseline;
            padding: 5px 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .check-item .value-label {
            color: #666;
            font-weight: 500;
            white-space: nowrap;
            text-align: right;
        }

        .check-item .value-content {
            word-break: break-all;
            padding-left: 10px;
            border-left: 2px solid #e1e4e8;
        }

        .check-item .values-container {
            margin: 10px 0;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            overflow: hidden;
        }

        .check-item .values-container .value-row:first-child {
            border-bottom: 1px solid #e1e4e8;
        }

        .check-item .values-container .value-row {
            margin: 0;
            border-radius: 0;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }

        .timeline-item {
            display: grid;
            grid-template-columns: 140px 1fr;
            align-items: center;
            gap: 15px;
            padding: 5px 10px;
        }

        .timeline-item:not(:last-child) {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 12px;
        }

        .timeline-label {
            font-weight: 500;
            color: #495057;
        }

        .timeline-value {
            color: #2c3e50;
        }

        .timeline-value .timestamp {
            margin: 0;
        }

        .reference-source {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .reference-source-header {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #4a5568;
            font-size: 0.9em;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .source-icon {
            color: #4a5568;
        }

        .reference-source-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #3182ce;
            text-decoration: none;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
            padding: 6px 10px;
            background: rgba(0,0,0,0.03);
            border-radius: 4px;
            transition: all 0.2s ease;
            word-break: break-all;
        }

        .reference-source-link:hover {
            background: rgba(0,0,0,0.05);
            color: #2c5282;
        }

        .external-link-icon {
            color: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .reference-source-link:hover .external-link-icon {
            opacity: 1;
        }

        /* New styles for Certificate Verification Guide */
        .certificate-verification-guide {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }

        .guide-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            color: #2c3e50;
            font-weight: 500;
        }

        .verify-icon {
            color: #3182ce;
        }

        .guide-steps {
            margin-left: 10px;
        }

        .guide-steps ol {
            margin: 0;
            padding-left: 25px;
        }

        .guide-steps li {
            margin: 8px 0;
            color: #4a5568;
            line-height: 1.4;
        }

        .guide-steps li:hover {
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Attestation Report</h1>
        <div class="claim-section">
            <p>
                This page performs client-side verification of an attestation token
                for a server running the <a href="https://github.com/comrade-coop/aapp-toolkit">aApp Toolkit</a>.
                The token validates that the server is running in a Confidential VM and proves what software build 
                it runs and that the HTTPS certificate it uses was generated securely inside a 
                Trusted Execution Environment (TEE).
            </p>
        </div>
        <div id="browserInstructions"></div>
        <div id="output"></div>
    </div>
</body>
</html>

